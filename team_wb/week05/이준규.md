# COW 5주차 학습 - Javascript 기본 문법

[참고 및 사진출처: 인프런 렛츠기릿 자바스크립트](https://www.inflearn.com/course/%EB%A0%88%EC%B8%A0%EA%B8%B0%EB%A6%BF-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/dashboard)

---
<br>

## 1. 계산기

### 계산기 프로그램 
- numOne을 먼저 입력받는다.
- 연산자를 입력한다.
- 화면에 나타나는 숫자를 지운다.
- numTwo 나중에 입력받는다.
-  ```=```연산자를 입력한다.
-  결과를 계산한다.
(단, 계산할 때 ```parseInt()```를 해줘야한다.)
-  계산이 끝나고 C를 누르면 초기화를 해준다.
 
---
<br>

### 관련 개념 및 팁
- 프로그램 시작 전에 순서도를 그리자.
![](https://velog.velcdn.com/images/junnkyuu/post/2daea27c-b292-4b49-bf50-5a0af3b21496/image.png)

- 복사 단축키: ```alt+shift+⬇️```
- 태그 변수는 ```$```를 붙인다.
- 중복이 되면 이상함을 느끼고 줄일 수 있는 것은 줄인다.
- 중복을 함수로 제거해줄 때 비슷한데 바뀌는 부분을 매개변수로 만들면 된다.
- 자바스크립트로 변수의 데이터를 바꾸면 화면도 바꾸는 것을 까먹지 말자.
- 고차함수: 함수를 리턴하는 함수, 함수간의 중복을 제거하기 위해 사용한다.
```
const func = (msg) => {
	return () => {
    	console.log(msg);
    }
};
// 고차함수
```

- 화살표 함수의 장점
    - 함수를 간결하게 표현
    - 상위 스코프의 ```this```를 그대로 사용 가능
    - 단일 표현식일 경우 ```return``` 생략 가능

- 화살표 함수의 단점
    - 앞에 ```function```이라고 표현하지 않아서 수많은 코드들이 있을 때 눈에 띄지 않음
    - 메소드로 사용할 수 없음


```
const func = (msg) => () => {
	console.log(msg)
};
// 더 간단한 고차함수
```
- ```event.target.textContext```: 이벤트가 발생하면 텍스트를 그대로 가져옴

- ```event``` 객체의 속성
    - ```type```: 이벤트의 타입
    - ```target```: 이벤트가 발생한 요소
    - ```currentTarget```: 이벤트가 현재 처리 중인 요소
    - ```timeStamp```: 이벤트가 발생한 시간
    - ```keyCode```: 키보드 이벤트에서 눌린 키의 코드
    - ```clientX```, ```clientY```: 마우스 이벤트에서 마우스 클릭 위치를 브라우저 창을 기준으로 나타냄
    - ```pageX```, ```pageY```: 마우스 이벤트에서 마우스 클릭 위치를 문서를 기준으로 나타냄
    
- ```event``` 객체의 메소드
    - ```preventDefault()```: 이벤트의 기본 동작을 취소
    - ```stopPropagation()```: 이벤트의 전파를 중단
    - ```stopImmediatePropagation()```: 이벤트의 전파를 즉시 중단
    - ```initEvent()```: 이벤트를 초기화

- if문이 중첩되는 것을 줄이자. 처음부터 정리를 잘하자.
	
    1. if문 다음에 나오는 공통된 절차를 각 분기점 내부에 넣는다
    2. 분기점에서 짧은 절차부터 실행하게 if문을 작성한다.
    3. 짧은 절차가 끝나면 ```return```(함수 내부의 경우)이나 ```break```(for문 내부의 경우)로 중단한다.
    4. else를 제거한다(이때 중첩 하나가 제거된다.)
    5. 다음 중첩된 분기점이 나오면 1 ~ 4를 반복한다.
    
- ```eval()```은 쓰지 않는 것이 좋다. 
    - ```eval()```은 문자열로 표현된 자바스크립트 코드를 실행하는 함수이다. 실행 중에 동적으로 생성된 코드를 실행할 수 있다.
        - 실행 중에 동적으로 생성된 코드를 실행할 수 있어서 악성 코드나 해커의 코드 인젝션 등의 위험이 생길 수 있음.
        - 코드 실행을 위해 문자열을 파싱하고 실행하기 때문에, 실행 속도가 느리고 코드의 유지보수가 어렵다.
        - 스코프를 동적으로 변경할 수 있기 때문에 전역 스코프에서 실행되는 코드가 의도치 않게 지역 스코프 변수에 접근하는 문제가 발생
        - ```eval()```함수 대신에 ```Function()``` 생성자를 사용하여 동적으로 생성된 실행하는 것이 더 안전함

```
const str = 'ler';
console.log('a' + str + 't("eval은 위험해요")');
// 이러면 alert창이 뜬다. 
```
- 보통 코드를 짤 때 초기상태를 맨위에 놓는다.
- 휠 눌러서 드래그하면 여러 개 선택이 가능하다.
- ```alt```를 누르고 방향키를 위아래로 누르면 작성한 줄 이동이 가능하다.
- ```1 + 2 + 3```이라고 한다면 ```1 + 2 =```이 numOne이 되고, 나머지 초기화 시킨 후 다시 numTwo인 3이랑 계산을 한다.

---
<br>

## 2. 숫자야구

### 숫자야구 프로그램 

- 상대편이 숫자 1 ~ 9 중에서 중복되지 않게 4개의 숫자를 고른다.
- 10번의 기회가 주어지고 상대편이 고른 숫자 4개를 맞힌다.
- 숫자를 맞히는 것 뿐 아니라 숫자의 순서까지 맞혀야한다.
- 틀릴 때 마다 힌트를 준다.
- 맞힌 숫자의 개수를 볼, 숫자의 순서를 스트라이크로 알려준다.
- 하나도 못맞힐 경우는 아웃이라고 한다.

---
<br>

### 관련 개념 및 팁

- 항상 순서도를 그리면서 시작한다.
![](https://velog.velcdn.com/images/junnkyuu/post/d80cb354-7bfb-4ad3-9249-ca245c755ca4/image.png)

- 무작위로 숫자 뽑기
    - ```Math.random()```을 사용한다.
        - ```Math.random()```는 완전한 난수가 아니다. 유사난수라고 하는데 컴퓨터 알고리즘을 사용하여 생성된 난수로 완전한 무작위 수열이 아니라 초기값과 알고리즘에 따라 계산된 값의 나열이다. 동일한 초기값을 사용하면 항상 같은 순서의 난수를 생성한다. 따라서 간단한 난수 생성 용도로는 괜찮지만 보완적인 용도나 암호학적인 용도에서는 사용하지 않는 것이 좋다.

    - ```Math.random()```은 0 <= num < 1이라서 이것을 정수로 바꿔줘야한다.
    	1. 9를 곱해서 0 <= num < 9로 만든다
        2. 1을 더해서 1 <= num < 10으로 만든다.
        3. 소숫점 아래 부분을 지우기 위해서 ```Math.floor()```를 사용한다.
        4. 그러면 1부터 9까지의 정수로 나온다.
        -> ```Math.floor(Math.random() * 9 + 1)```
        
- 반올림은 ```Math.round()```, 올림은 ```Math.ceil()```
- 단순히 값들을 쓸 때는 배열, 속성이 다르고 그 값들의 이름을 붙이려면 리터럴을 사용한다.
- 인덱스가 0부터 시작하는 것을 항상 기억하자
- 뽑은 것은 빼줘야 할 때 ```splice```를 사용한다.
- 항상 극단적인 것도 생각해야한다. 
    - 숫자가 6개 밖에 없는데 인덱스로 8을 뽑으면 ```undefined```값이 들어간다.
    - 해결방법
        - ```
        for(let n = 0; n < 4; n ++) {
        	const index = Math.floor(Math.random() * (numbers.length));
            answer.push(numbers[index]);
            numbers.splice(index, 1);
        }
        ```
 - 코드를 수정해야하는 일이 필요하므로 숫자를 쓰는 것 보다 변수를 사용한다. 9라고 하기 보다는 ```numbers.length```로 한다.
 - ```button``` 달린 ```input```이 있으면 ```form```으로 감싸주는 것이 표준에 가깝다.
 - 새로고침을 누르면 값이 날라가기 때문에 ```event.preventDefault()```를 사용한다.
 - 다음값 입력 받을 때는 보통 지워준다.
 - 태그를 변수에 넣을 때 일정의 규칙을 만들어서 구분을 하자. ```$,T,_``` 이런 것 사용
 - ```new Set(input);``` 이면 중복되는 숫자 제거한다.
 - ```alert```는 ```return```값이 ```undefined```이다.
 - 복사를 한다면 무조건 중복이라 생각하고 함수로 빼내자
 - 배열에서 반복할 때는 ```arr.forEach()```를 사용한다.
 - ```map```도 배열에서 반복으로 사용한다.	 
    
    ```
    const array = [1, 2, 3, 4];
    const result = [];
    
    for(let i = 0; i < array.length; i ++) {
    	result.push(array[i] * 2);
    }
    
    array.map((element, i) => {
    	return element * 2;
    });
 	
    ```

- ```const```키워드를 사용하면 변수를 재할당하는 것은 불가능하다. 그러나 배열은 변경이 가능하다. 배열은 배열의 값을 변경하는 것이 아니라 참조값을 변경하는 것이 불가능하다. 즉 ```const```로 선언된 배열을 조작하는 것은 가능하지만 참조값을 변경하는 것은 불가능하다.

- forEach, map을 사용하는 이유는 더 깔끔하게 사용할 수 있다. 
```
Array(9).fill(0).map((element, i) => {
	return i + 1;
})
// 1,2,3,4,5,6,7,8,9
```
	
- 즉, ```forEach```는 배열 요소를 반복하는데 요소 하나하나에 함수를 실행해주고, ```map```은 여기에다가 ```return```을 해줘서 기존 배열을 건드리지 않고 새로운 배열을 만들어준다.

---
<br>

## 3. 로또 추첨기

### 동기 vs 비동기

자바스크립트는 단일 쓰레드 언어이다. 따라서 한 번에 하나의 작업만 수행이 가능하다. 동기적으로 코드를 작성하면 작성한 순서에 따라 코드를 실행하는데 하나의 코드가 실행하는데 오래걸리면 나머지 코드들도 실행하는데 오래걸린다. 그러나 비동기 처리를 사용하면 코드를 병렬적으로 실행해서 아나의 코드 실행이 끝날 때까지 다른 코드를 실행할 수 있다. 이를 통해 시간이 오래걸리는 네트워크 요청이나 파일 입출력에 유용하고 브라우저가 멈추는 문제를 방지하고, 사용자 인터페이스가 응답하는 등의 이점을 가질 수 있다.

로또 추첨기에서 주로 사용할 개념은 비동기라는 개념이다. 비동기는 동기의 반댓말로 실제로 코딩한 순서와 다르게 동작하는 코드를 비동기 코드라고 한다. 지금까지 사용했던 이벤트 리스너가 대표적인 비동기 코드이다. 이벤트 리스너도 코드는 위에 적혀있는데 밑에서 나중에 실행되므로 비동기 코드이다.

에디터에 적은 코드의 순서와 실제 동작 순서가 다르므로 어떤 원리로 이렇게 동작하는지 익혀야한다. 원리를 익히다보면 자바스크립트를 공부할 때 반드시 알고 넘어가야 하는 스코프나 클로저 같은 개념들도 함께 알게 된다.

<br>

### 로또 추첨기 프로그램

- 1부터 45개의 숫자 중에서 6개를 뽑는다.
- 보너스 숫자도 1개 뽑는다.
- 총 7개의 숫자를 랜덤으로 뽑는다.
- 각각의 공을 1초 마다 1개 씩 뜨게 설정한다.

<br>

### 관련 개념 및 팁

- 순서도를 그린다.![](https://velog.velcdn.com/images/junnkyuu/post/dc7765e8-29ea-4452-a56f-61a1a2a4f3c1/image.png)
- 랜덤인 숫자 45개 만들기
	```
	Array(45).fill(0).map((el,i) => i + 1);
	```
- arr.splice(2,1); 이면 2번 인덱스에서 1개를 제거한다는 의미인데 빼낸 값도 배열이다. 따라서 값으로 저장을 하려면 따로 변수를 지정한다.
	```
	var spliceVar = arr.splice(2,1);
	var someVar = spliceVar[0];
	```
- 피셔 에이츠 셔플: 랜덤으로 섞인 숫자에서 빼서 따로 저장을 하면 이것도 랜덤이 된다. 
- ```while```은 몇번 반복해야할지 모르겠을 때, 알때는 ```for```을 쓴다.
- 작은 숫자부터 보여주기 위해 정렬한다.

```
	const winBall = shuffle.slice(0, 6).sort((a, b) => a - b);
```
- ```arr.slice(index, index)```로 배열을 자를 수 있다. ```map```과 같이 원본은 변하지 않는다.

```
	const arr = [0,1,2,3,4,5]
	const slicedArr[] = arr.slice(0, 3); // 0은 포함, 3은 포함하지 않고 자른다.
	console.log(slicedArr);
	// [0,1,2]
```
- ```splice(index, 개수)```는 원본은 수정한다.
- 정렬하려면 ```sort```를 사용한다.
```
    array.sort((a, b) => {
		return a - b;
	});
	// 오름차순 정렬
    
    alp.slice().sort((a,b) => a.localeCompare(b));
    // 문자를 정렬
```
- ```sort```도 ```splice```와 같이 원본을 수정한다.
- 원본을 유지하려면 ```slice```로 참조가 아닌 복사를 한 후 ```sort```하면 된다.
```
	array.slice().sort((a, b) => {
		return a - b;
	});
```
- ``` sort((a, b) => (a - b));```는 2개를 빼서 위치를 유지할지말지를 결정하는 것이다. 작으면 유지 크면 바꾸기 이런식으로 한다.
- 즉 원본을 유지하려면 중간에 ```slice```를 끼워넣자
- ```setTimeout(() => console.log('hello'), 1000);``` 이러면 밀리세컨드 단위라서 1초뒤에 hello가 출력된다.
- 반복되는 것을 매개변수로 바꿔서 함수로 만든다. 
- 중복을 제거하는 것을 refactoring이라고 한다. 단, 중복을 제거하느라 코드가 안돌아가면 안된다.
- 자바스크립트의 시간은 정확하지 않으므로 정확한 시간이 필요하면 쓰지 말자. 왜냐하면 하고 있는 일이 오래걸리면 일을 다 하고 타이머가 실행되기 때문에 시간이 정확하지않다.
- ```func```는 함수, ```func()```는 함수의 리턴값이다.
```
setTimeout(func, 3000);
// 이런식으로 해야한다.
```
- ```var```과 ```let```의 차이
    - 변수는 스코프라는 것을 가진다. ```var```는 함수를 경계로 접근이 나누어지는 함수 스코프를 가지고 ```let```은 블록을 경계로 접근이 나누어지는 블록 스코프를 가진다.
    ```
    function b() {
    	var a = 1;
    }
    console.log(a);
    // Uncaught ReferenceError: a is not defined
    // var는 함수 스코프를 가지기 때문에 함수를 벗어나면 접근할 수 없다.
    ```
    
    ```
    if(true) {
    	let a = 1;
    }
    console.log(a);
    // Uncaught ReferenceError: a is not defined
    // let은 블록 바깥에서 접근했기 때문에 접근 할 수 없다.
    ```
    
    ```
    for(var i = 0; i < 5; i ++) {}
    console.log(i);
    // 5 
    // var로 선언했기 때문에 블록 바깥에서도 접근이 가능하다.
    ```
    - 함수 스코프를 가진 ```var```과 비동기 함수가 만나면 클로저문제가 발생한다.
    - var로 인한 문제를 해결하려면 함수로 감싸서 매개변수를 사용하면된다. 
    - 이것을 클로져로 해결했다고 한다.
    - 함수와 함수 바깥의 변수 관계를 말한다.
    - 이 문제를 애초에 없애려면 ```let```을 쓰면 된다.
    
- ```(function() {})();``` 이러면 함수를 바로 호출할 수 있다.

<br>

### 특히 기억해야할 내용

- 피셔 예이츠 셔플 알고리즘
숫자를 무작위로 섞는 방법이다. 먼저 무작위 인덱스를 나나 뽑은 후, 그에 해당되는 요소를 새로운 배열로 옮긴다. 이를 반복하다 보면 새 배열에 무작위로 섞인 숫자들이 들어간다.

- sort
비교 함수에 적힌 내용대로 배열을 정렬하는 메소드이다. 원본을 안바꾸려면 ```slice```를 사용한다.
```배열.sort(비교함수)```

- setTimeout
지정한 시간(밀리초) 뒤에 지정한 작업을 수행하는 타이머이다.
```
setTimeout(() => {
	// 내용
}, 밀리초);
```

- 스코프
함수 스코프를 가지는 ```var```과 비동기 함수가 만나면 매우 복잡한 클로저 문제가 생긴다. 따라서 이를 방지하기 위해 ```let```을 사용한다. 

---
<br>

## 4. 가위바위보 게임

컴퓨터와 가위바위보를 해서 몇 번 이겼는지 점수를 기록하는 게임이다.

### 가위바위보 프로그램
- 컴퓨터가 50밀리세컨드 동안 가위바위보를 반복하고 있다.
- 사용자가 가위바위보 중 하나의 버튼을 선택한다.
- 사용자가 선택을 하면 반복하고 있는 가위바위보를 멈추고 한 개를 보여준다.
- 이기면 승부카운트를 올려준다.

<br>

### 관련 개념 및 팁
- 순서도![](https://velog.velcdn.com/images/junnkyuu/post/d7b77bc9-b61b-4380-bf2f-a482b0f256e5/image.png)
- 절대경로는 C드라이브에서 출발하고 상대경로는 현재 폴더 기준으로 한다.
- 서버에 이미지르르 요청하는 횟수를 줄이기 위해 하나의 이미지를 사용하기도 한다.
- 변수명은 고유한 것이 좋다.
- 백그라운드랑 백그라운드 사이즈는 같이 설정해줘야 오류가 발생하지않는다.
- ```else```보다는 ```else if```로 명확하게 해주는 것이 좋다.
- ```setInterval```을 통해 반복해준다.
    ```
    setInterval(() => {
    	console.log('hello');
    }, 1000);
    ```
- ```setIntervval```, ```setTimeout```은 정확한 시간이 아닐 수 있다. 왜냐하면 앞의 코드가 끝나고 실행되는데 앞의 코드가 길면 나중에 실행되므로 정확한 시간으로 사용할 수 없다.
- 최대한 시간을 보장해야하면 ```setInterval```, 아니면 ```setTimeout```을 사용한다.
- ```setInterval```은 ```clearInterval``` 로 제거하고, ```setTimeout```은 ```clearTimeout```으로 제거한다.
- ```rspX[computerChoice]```라고 표현해야한다. ```rspX.computerChoice```는 틀린 표현이다. 왜냐하면 값이 들어가야할 자리이므로 ```.computerChoice```는 들어갈 수 없다.
- 버튼을 1초동안 클릭 못하게 removeEventListener을 사용하면 된다. 이벤트가 전달되지않게.
- 버튼 클릭이 안되게 하려면 ```flag```변수를 사용하면 된다.(```true```, ```false```를 이용)
- 함수도 객체이다. 따라서 ```객체 === 객체``` 이러면 ```false```가 나온다. 
```
const a = {};
const b = a;
a === b;
// 객체는 참조를 해줘야 같다고 하면 참이나온다.
```
``` 
const fun = () => {
	console.log('고차함수입니다.');
}

fun(1) === fun(1);
// 함수도 객체이므로 false가 나온다.

태그.addEventListener('click', fun(1));
태그.removeEventListener('click', fun(1));
// 이러면 제거되지 않는다.

const fun1 = fun(1);
fun1 === fun1
// 객체를 변수에 담아서 같다고 놓으면 참이 나온다.

태그.addEventListener('click', fun1);
태그.removeEventListener('click', fun1);
// 이러면 제거된다.
```
- 규칙이 안보일 때는 문자열을 숫자로 대응시켜서 규칙을 찾을 수 있다.
- ```||```을 사용할 때 ```[].includes```를 사용하면 간단하게 표현할 수 있다.
```
diff === '고양이' || diff === '사자' || diff === '강아지'
['고양이', '사자', '강아지'].includes(diff);
// 배열에 diff가 포함되어있는지 참 거짓으로 반환
// 이렇게 표현하면 더 간단하다.
```
- 코드 중간중간에 콘솔로 찍어보면 도움이 된다.

---
<br>

## 5. 반응속도 테스트

반응속도가 얼마나 빠른지 확인하는 반응속도 테스트 프로그램을 만든다. 시간을 측정해야 하므로 시간과 관련된 메소드를 제공하는 Date 객체를 사용한다.

### 반응속도 테스트 프로그램
- 처음에 파랑 화면을 보게 된다.
- 파랑 화면은 대기화면
- 화면을 한 번 클릭하면 빨강 화면으로 전환되는데 준비 화면을 의미한다.
- 준비 화면에서 임의의 시간이 지난 후에 초록 화면으로 자동 전환된다.
- 초록 화면을 보자마자 클릭하면 초록 화면이 뜬 시각과 클릭한 시각의 차이를 구해 반응속도를 측정한다.
- 준비 화면(빨강 화면)일 때 클릭한다면 성급했다는 메세지가 나오고 다시 클릭하도록 대기 화면(파랑 화면)으로 보낸다.

<br>

### 관련 개념 및 팁
- 순서도
![](https://velog.velcdn.com/images/junnkyuu/post/e8f37777-38e8-447c-b5b4-00fad34d9f9c/image.png)

- 자바스크립트에 데이터를 만들고 화면과 통일시켜라 이게 주요 개념이다. 
- 클래스는 여러개의 태그를 동시에 선택하고 싶을 때도 사용하지만, 태그에 특정한 역할이 부여되었다를 보여주기 위해도 사용한다.
- 자바스크립트로 HTML의 클래스를 불러올 때는 ```className```를 사용한다.
- ```태그.classList.contains('클래스');```
해당 클래스가 들어 있다면 ```true```, 들어있지 않다면 ```false```가 된다.
```
태그.classList.add('클래스'); // 추가
태그.classList.replace('기존클래스', '수정클래스'); // 수정
태그.classList.remove('클래스'); // 제거
```
- 타입스크립트로 코딩을 하는 것이 오류 발생을 줄이기 위해서 좋다.
- 현재 시각을 가지고 있는 객체를 생성하고 싶으면 ```new Date();```를 하면 된다.
    - ```new Date(년,월,일,시,분,초);```
    - ```Date``` 에서 월만 0부터 시작한다.
    - 년을 가져올때는 ```getYear```가 아니라 ```getFullYear```를 써야한다.
    - ```Int1```는 다양한 지역화 기능을 제공한다. 날짜, 시간, 숫자, 통화 등을 각 나라에서 사용하는 형태로 변환할 수 있도록 도와준다.
- 주석을 다는 버릇을 하자. 
- 큰 시간 - 작은 시간 = 시간 간격(밀리초)
- 변수 선언할 때 스코프를 생각해야한다.
- ```let```으로 변수 선언하기 이전에 변수를 사용할 수 없다. 반면 ```var```은 가능하다.
- 평균 구하는 방법
```
const average = records.reduce((a, c) => a + c)/ record.length;
``` 
- 실수로 예전값이 들어있을 수 있으니까 ```null```을 넣어서 초기화 시켜준다.
- 숫자 작업을 하는데 ```NaN```이 나오면 무엇인가 잘못되었다는 의미이다.
- ```reduce```는 배열의 값들을 하나의 새로운 값으로 합치는 메소드로 다음과 같이 구성된다. 여러 개의 값을 하나의 값으로 줄여주니까 ```reduce```이다.
- ```return```을 꼭 해줘야한다. 아니면 ```undefined```가 된다.
```
배열.reduce((누적값, 현재값) => {
	return 새로운 누적값;
}, 초기값)
```
```
[1,2,3,4].reduce((a, c) => (a + c), 0);
// a:0 c:1
// a:1 c:2
// a:2 c:3
// a:6 c:4
// 10
```
```
// 초기값이 없을 경우 첫 번째 값이 초기값이다.
[1,2,3,4].reduce((a, c) => (a + c));
// a:1 c:2
// a:3 c:3
// a:6 c:4
// 10
```
- 타이머, 이벤트리스너는 필요없으면 지워줘야한다. 아니면 버그를 발생시킨다.
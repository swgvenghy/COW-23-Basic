# JavaScript

모던 자바스크립트 튜토리얼 : [https://ko.javascript.info/](https://ko.javascript.info/)

mdn web docs: [https://developer.mozilla.org/ko/](https://developer.mozilla.org/ko/)

- **Uncaught ReferenceError: consle is not defined** → console 입력 중에 오타를 내면 발생하는 에러. console을 브라우저에서 제공하는 기능이기 때문에 오타가 나서는 안 된다. 또한 대소문자도 구분하므로 모든 글자를 소문자로 적여야 한다.
- **Uncaught TypeError: console.lg is not a function** → console은 제대로 입력했으나 log에서 오타를 냈을 때 발생하는 에러이다. log는 console의 기능 중 일부이기 때문에 오타가 있어서는 안 된다. 또한 대소문자도 구분한다.
- **Uncaught SyntaxError: missing ) after argument list** → 따옴표를 사용하지 않았을 때 발생하는 에러이다. ‘Hello World’ 같은 문자는 `(백틱)이나 '(작은따옴표) 또는 "(큰따옴표)로 감싸줘야 한다.
- **Uncaught SyntaxError: Invalid or unexpected token** → 따옴표의 짝을 맞추지 않았을 때 발생하는 에러이다. 시작과 끝의 따옴표 종류가 같아야 한다.

코드를 한 덩어리씩 실행해 결과를 출력하는 방식을 **인터프리터(interpreter)** 방식이라고 한다.

브라우저의 콘솔은 코드를 한 줄씩 입력받고(Read), 받은 입력을 평가(Eval)한 후 결과를 출력(Print)한다. 그 후 다시 프롬프트가 나타나 새로운 입력을 기다린다(Loop). 이러한 특성 때문에 콘솔을 REPL(Read-Eval-Print-Loop)이라고 한다.

## 순서도에서 사용하는 도형과 기호

- **두 겹의 원**: 시작 과 끝
- **타원**: 일반 절차
- **마름모**: 판단 절차
- **두 겹의 사각형**: 특수한 상황(대기, 이벤트 발생)
- **화살표**: 다음 절차로 가능 흐름

## 세미콜론

자바스크립트는 하나의 명령이 끝날 때 세미콜론을 붙여도 되고 붙이지 않아도 된다. 세미콜론은 보통 명령문의 끝을 의미한다.

## 주석

```jsx
// 한 줄 주석
/*
여러 
줄 
주석
*/
```

## 자료형

**값(value)**은 프로그램이 조작할 수 있는 데이터를 의미한다. 값에는 여러 가지 종류가 있으며 이런 값의 종류를 **자료형(data type)**이라고 한다.

- **문자열(string)**: 프로그래밍에서 하나의 글자를 문자라고 하는데 문자들이 하나 이상 나열되어 있다고 해서 문자열이라고 한다. 시작과 끝이 따옴표로 감싸진 값이 문자열이다.
    - **\n**: 줄바꿈
    - **\?**: 역슬레쉬 뒤에 글자는 무시함
    - **“’” or ‘\’’**: 따옴표를 출력하고 싶을 때 사용함
    - **+**: +를 통해서 문자열을 합칠 수 있음
        - 문자열과 다른 자료형을 더하게 되면 다른 자료형이 문자열로 바뀐 후 문자열과 더해진다. 이처럼 값의 자료형이 바뀌는 현상 또는 바꾸는 행위를 **형 변환(type casting)**이라고 한다.
- **숫자**: 정수와 실수를 포함한 모든 수이다.
    - **5e4**: 50000을 의미. e뒤에 값은 0의 개수를 정함
    - **0b?**: 2진법
    - **0?**: 8진법
    - **0x?**: 16진법
    - **NaN**: Not a Number
    - **Infinity**: 무한
- **불 값(boolean)**: 1과 0은 참(true)과 거짓(false)에 대응된다.
    - NaN은 비교연산(!=을 제외)에서 false를 출력함
    - 문자열과 문자열을 비교하면 문자열의 번호로 비교함
    - 문자열과 숫자를 비교하면 문자열이 숫자인경우 숫자로 형변환된 후 비교하고 문자열이 문자인경우 NaN으로 인식하여 비교함
    - **===, !==**: 값을 비교할 때 값뿐만 아니라 자료형까지도 같은지 비교함
    
    ### 논리연산자
    
    - **&&**: and
    - ****||****: or
    - **!!**: boolean 형변환 (**’ ’, 0, NaN, undefined, null, document.all** 은 false)
- **undefined**: 보통 반환할 결과값이 없을 때 나온다. 빈 값
- **null**: 빈 값

**typeof ?**: ?의 자료형을 알려준다

```jsx
typeof ‘문자열’;
// "string"
typeof 123;
// "number"
typeof true;
// "boolean"
```

**parseInt()**: 문자열을 정수로 변환해주는 메소드

**Number()**: 문자열을 숫자로 변환해주는 메소드

**parseFloat()**: 문자열을 소수를 포함한 수로 변환해주는 메소드

```jsx
parseInt("3월");
// "3"
parseInt(111, 2);
// 7 (2진법으로 해석)
Number("3월");
// "NaN"
```

**.charCodeAt()**: 문자의 번호를 알려주는 메소드

## 선언문

프로그램을 만들 때는 잠깐 동안 특정한 값을 저장해야 하는 상황이 자주 발생한다. 이때 사용하는 것이 변수이다. 선언문은 변수를 선언할 때 사용하는 문이다.

- **let**: 변수 선언
    
    ```jsx
    //let 변수 = 값;
    let num = 123;
    let empty;
    //기본값인 undefined가 할당된다
    ```
    
- **const**: 상수 선언 (변하지 않는 수)
- **var**: 변수 선언(다시 선언할 수 있음)

## 조건문

주어진 조건에 따라 코드를 실행하거나 실행하지 않는 문이다.

```jsx
if(조건문){
	동작문;
}else if(조건문){
	동작문;
}else{
	동작문;
}
```

```jsx
switch (값){
	case 'A':
		동작문;
		break;  //break;를 안적으면 그 밑에 동작문까지 다 실행함
	case 'B':
		동작문;
		break;
	default:  //else와 같은 역할
		동작문;
}
```

### 삼항연산자

삼항 연산자는 문이 아니라 식이기 때문에 결과값이 나온다.

```jsx
//**조건식** ? **참일 때 실행되는 식** : **거짓일 때 실행되는 식**
5 > 0 ? '참' : '거짓';
```

## 반복문

동작문을 계속 반복하는 문이다.

```jsx
while(조건문){
	동작문;
}
```

```jsx
for(시작(초기화식); 조건문; 종료식(증감식)){
	동작문;
}
```

**break**: 특정 조건을 달성해서 반복문을 탈출하고 싶을 때 사용한다.

**continue**: 특정 조건을 달성해서 해당 코드를 건너뛰고 싶을 때 사용한다.

```jsx
for(시작(초기화식); 조건문; 종료식(증감식)){
	for(시작(초기화식); 조건문; 종료식(증감식)){
		동작문;
	}
}
```

## 별찍기

.repeat(): 해당 동작을 몇번 반복할지 정하는 메소드

```jsx
for(let i = 0; i < 9; i += 2){
	console.log("*".repeat(i+1));
}
/*
*
***
*****
*******
*********
*/

for(let i = 0; i < 9; i += 2){
    console.log("*".repeat(9-i));
}
/*
*********
*******
*****
***
*
*/

for(let i = 0; i < 5; i++){
    console.log(" ".repeat(i) + "*".repeat(5 - i));
}
/*
*****
 ****
  ***
   **
    *
*/

for(let i = 0; i < 5; i++){
    console.log(" ".repeat(5 - i) + "*".repeat(i + 1));
}
/*
    *
   **
  ***
 ****
*****
*/
```

## **객체**

자료형의 일종으로 다양한 값을 모아둔 또다른 값이다. 객체의 종류로는 크게 배열(array), 함수(function), 배열이나 함수가 아닌 객체로 나눌 수 있다.

- **배열**: 다양한 값을 나열하는 경우 사용함
    - **.length**: 배열의 길이를 나타냄
    
    ```jsx
    const fruits = ['사과', '오렌지', '배', '딸기'];
    for(let i = 0; i < fruits.length; i++){
        console.log(fruits[i]);
    }
    
    const arrayofArray = [[1,2,3],[3,4]];
    for(let i = 0; i < arrayofArray.length; i++){
        for(let j = 0; j <= arrayofArray[i].length; j++){
            console.log(arrayofArray[i][j]);
        }
    }
    ```
    
    - **.unshift**: 배열 앞에 값을 추가할 때 사용함
    - **.shift**: 배열 앞에 값을 제거할 때 사용함
    - **.push**: 배열 뒤에 값을 추가할 때 사용함
    - **.pop**: 배열 뒤에 값을 제거할 때 사용함
    - **.splice(인덱스, 개수)**: 인덱스를 기준으로 개수만큼 제거
    **.splice(인덱스)**: 인덱스을 기준으로 뒤에 값을 다 제거
    **.splice(인덱스, 개수, 값, 값, …)**: 인덱스를 기준으로 개수만큼 제거하고 값을 추가함
        
        ```jsx
        const fruits = ['사과', '오렌지', '배', '딸기'];
        
        fruits.splice(1, 2); //오렌지, 배 제거
        fruits.splice(1); //오렌지, 배, 딸기 제거
        fruits.splice(1, 2, 레몬, 귤); //오렌지, 배 제거하고 레몬, 귤을 추가함
        ```
        
    - ******************.includes(값)******************: 값을 포함하는지 안하는지 알아냄. true of false
    - ****************.indexOf(값)****************: 앞에서부터 찾아서 해당 값의 인덱스 값을 알려줌(없으면 -1)
    - ****************.lastIndexOf(값)****************: 뒤에서부터 찾아서 해당 값의 인덱스 값을 알려줌

- **함수**: 일정한 동작을 수행하는 코드를 의미한다. 함수를 미리 만들어두고 원할 때 실행해 정해진 동작을 수행하게 할 수 있다. 함수를 만들 때는 보통 **function** 예약어를 사용하거나 **=>(화살표)** 기호를 가용한다. 화살표 기호를 사용한 함수를 **화살표 함수(arrow function)**라고 한다.
    
    ```jsx
    const a() {} //함수 선언문
    const b = function() {}; //함수 표현식
    const c = () => {}; //화살표 함수
    
    a(); //호출
    
    function a() {
    	return "hello";
    	console.log("hi");
    	//함수는 기본적으로 return undefined;를 한다.
    }
    //"hello"출력
    //return은 값을 반환한다는 의미를 가지고 있으면서 함수의 끝을 의미한다.
    ```
    
    ```jsx
    /*
    function a(parameter) {
    	console.log(parameter);
    }
    
    a('argument');
    */
    
    function add(x, y) {
    	console.log(arguments);
    	return x + y
    }
    
    add(2, 3)
    // [2, 3]
    // 5
    // 인수를 안적으면 매개변수에는 기본값인 undefined가 할당된다.
    ```
    

- **객체 리터럴**: 배열이나 함수가 아닌 객체를 의미한다. 객체는 여러 개의 변수를 하나의 변수로 묶을 때 사용한다.
    - **delete 객체.속성이름**: 객체 내부의 속성을 제거
    
    ```jsx
    const 객체 = {
    	속성 이름1 = 속성값1,
    	속성 이름2 = 속성값2,
    	...
    };
    
    const me = {
    	name = "최진엽",
    	year = 2003,
    	month = 8,
    	date = 15,
    	gender = 'M',
    	'cow-team' = 'js' //특수문자나 숫자가 들어가면 속성 이름에 따옴표를 해야한다.
    };
    
    console.log(me.name);
    console.log(me['name']);
    console.log(me.hello); //undefined
    ```
    

배열과 함수가 객체인 이유는 객체의 성질을 모두 다 사용할 수 있기 때문이다. 배열과 함수에서도 속성들을 추가할 수도 있고 수정 및 제거할 수도 있다. 객체는 함수와 배열을 포함하는 개념이라서 {}를 사용해 만든 객체를 객체 리터럴이라고 따로 부르는 것이다.

객체의 속성 값으로 함수를 넣었을 때 이 속성을 특별히 메소드(method)라고 한다.

console.log를 예로 들면 console이라는 객체 안에 log라는 메소드를 호출하는 것이다.

객체를 비교하면 언제나 false가 나온다 그렇기 때문에 객체를 비교할 때는 객체를 따로 변수에 저장하고 변수를 통해서 비교해야한다.

변수는 또 다른 공간에 있는 원시값을 동시에 공유하는 반면 객체는 자기만의 공간에 값을 저장하기 때문에 서로 비교할 수 없는 것이다.

```jsx
const a = {name : 'jinyeop'};
const b = a;
a.name = 'hero';
console.log(b.name); // hero

let a = 'jinyeop';
let b = a;
a = 'hero';
console.log(b); // jinyeop
```

## 순서도

절차를 세울 때는 모든 가능성을 고려해야 한다.

프로그램 절차를 만들 때의 원칙

1. 프로그램 절차의 개수는 정해져 있어야 한다.
2. 각 절차는 항상 같은 내용이어야 한다.
3. 모든 가능성을 고려해야 한다.
4. 예시는 절차를 검증하는 데 사용한다.

# 끝말잇기

위의 원칙을 바탕으로한 끝말잇기 프로그램 절차

1. 게임에 몇 명이 참가할지를 선택한다.
2. 참가자 순서를 정한다
3. 첫 번째 사람이 어떤 단어를 말한다.
4. 다음 사람이 어떤 단어를 말한다.
5. 절차 4에서 말한 단어가 올바른지 판단한다.
6. 올바르다면 그 다음 사람이 어떤 단어를 말한다.
7. 올바르지 않다면 틀렸다고 표시한다.
8. 게임 계속 진행 (절차 4로 이도)한다.

**prompt()**: 사용자로부터 값을 입력받는 함수 (문자열)

**alert()**: 사용자의 확인을 요구하는 함수

**confirm()**: 사용자에게 경고 메시지를 포시하는 함수 (true or false)

### HTML태그 선택하기

보통 자바스크립트에서 HTML태그를 가져오는 것을 선택한다고 표현하는데 선택하기 위해서는 특별한 함수와 특별한 방법을 사용한다.

**document.querySelector(’선택자’)**: HTML태그를 선택하는 것

```jsx
document.querySelector('input');
```

**document.querySelectorAll(’선택자’)**: HTML의 모든 태그를 선택하는 것

**.addEventListener(’이벤트 이름’, 리스너 함수)**: 이벤트를 추가하는 것

```jsx
document.querySelector('input').addEventListener('input', (event) => {
    console.log('글자 입력', event.target.value);
});

const onClick = function() {
    console.log('버튼 클릭');
}

document.querySelector('button').addEventListener('click', onClick);
```

**.textContent**: 태그안에 텍스트를 지정하는 것(div, span, p etc…)

**.value**: 입력창에 텍스트를 지정하는 것(input, textarea, select etc…)

**.focus**: 입력창을 하이라이트

---

- [√] multi line comment에 대한 내용을 추가해주세요
- [√] 문자열간의 사칙 연산(+, -, /, *)에 대한 동작 방식을 설명해주세요
    - 문자열을 +하면 문자열이 합쳐집니다. 문자열안의 값이 문자인경우 -, /, *를 하게 되면 NaN이라는 결과가 나오지만, 문자열안의 값이 숫자인 경우 자동으로 형변환되어 연산된 값이 나옵니다.
- [√] "2.1", "2.4", "2.5", "2.9"를 parseInt()로 정수로 바꾸면 어떤 결과가 나오나요?
    - 모두 다 2라는 결과가 나옵니다.
- [√] 컴퓨터는 왜 소수점 계산에서 미세한 오차가 발생하나요? 이를 해결하기 위해선 어떤 방법들이 있나요?
    - 소수점을 이진법으려 변경하기 힘들어서 그렇습니다. 그래서 부동소수점 방식을 이용해야합니다.
- [√]연산자의 우선순위에 대해서 작성해주세요
    1. (괄호)
    2. 단항 연산자 ( --, ++, ! )
    3. 산술 연산자 ( *, /, %, +, - )
    4. 비교 연산자 ( >, >=, <, <=, ==, ===, !==, != )
    5. 논리 연산자 ( &&, || )
    6. 대입(복합 대입) 연산자 ( =, +=, -=, *=, /=, %= )
- [√] 변수 선언에 let 키워드를 이용하는 이유가 뭘까요?
    - let은 var과 다르게 block-level-scope라서 전역 변수를 남발하는 사태를 줄일 수 있고, 중복 선언이 불가능 하고, 호이스팅이 불가능 하기 때문입니다. 변수 호이스팅이란 변수가 선언도 되지 않았는데 참조가 가능한 현상을 의미합니다.
- [√] 변수를 선언하지 않아도 제공하는 도구들은 뭐라고 부르나요?
    - 암묵적 전역이라고 부릅니다.
- [√] 같은 변수 이름을 2번 선언하면 어떤 에러가 발생하나요? 항상 발생하나요?
    - `Uncaught SyntaxError: Identifier '변수명' has already been declared` 라는 에러가 발생합니다.  var은 재선언이 가능하기 때문에 var같은 경우 발생하지 않습니다.
- [√] 띄어쓰기 대신 대문자로 바꿔서 명명하는 변수 명명법을 무엇이라고 하나요? 그 외에 다른 방법은 무엇이 있니요?
    - camelCase라고 합니다. 그 외에 _ 또는 $기호를 사용하는 방법이 있습니다.
- [√] 변수에 값을 넣는 행위를 뭐라고 부르나요?
    - 변수 할당이라고 합니다. 변수를 선언함과 동시에 값을 넣어 주는 것은 변수 초기화라고 합니다.
- [√] js의 식(expression)과 문(statement)의 예시와 차이점에 대해서 작성해주세요
    - 식은 하나의 값을 만들어내는 것입니다. 예로는 값, 연산식, 리터럴 그리고 함수 호출이 있습니다. 문은 기본적으로 무언가를 수행하는 것으로써 문은 함수의 인자, 대입 연산의 값 또는 연산자의 피연사자로 사용할 수 없습니다. 예로는 조건문, 반복문 등이 있습니다.
- [√] let var의 공통점과 차이점에 대해서 작성해주세요
    - var과 let의 공통점은 재할당이 가능한 것이고, 차이점은 중복 선언이 불가능 하다는 것입니다.
- [√] 왜 var는 let과 다르게 같은 변수명으로 여러 번 선언할 수 있을까요?
    - var은 변수 선언 시 선언 → 초기화가 동시에 이루어지기에 변수 호이스팅이 가능하기 때문입니다.
- [√] var가 잘 쓰이지 않는 이유는 뭘까요?
    - var은 function-level-scope라서 전역 변수가 남발할 수 있는 사태가 발생하고, 변수 중복 선언이 가능하여 코드의 혼란을 줄 수 있고, 변수 호이스팅이 발생하기 때문입니다.
- [√] 중첩 조건문을 피하면 좋은 이유가 무엇일까요?
    - 조건문을 많이 중척할수록 코드가 복작하여 코드의 가독성이 떨어지고 비효율적이며 혼란을 줄 수 있기 때문입니다.
- [√] for문과 while문 중 하나를 선택해 사용하는 기준은 무엇일까요?
    - for문은 주로 배열을 다룰때 사용하며, 조건을 걸어서 반복 횟수를 정확하게 할 때 사용하고, while문 같은 경우 특정 조건을 달성하면 종료되게끔 무한반복을 할 때 사용합니다.
- [√] for..in / for..of 에 대해서 설명해주세요.
(in / of 를 사용할 수 있는 대상은 무엇이 있는 지, 왜 그 대상들은 사용할 수 있는 지!)
    - for in 반복문은 객체의 속성들을 반복하여 작업을 수행할 수 있습니다. 모든 객체에서 사용이 가능합니다. for in은 객체의 key 값에 접근할 수 있지만, value 값에 접근하는 방법은 제공하지 않습니다. 자바스크립트에서 객체 속성들은 내부적으로 사용하는 숨겨진 속성들을 가지고 있습니다. 그 중 하나가 [[Enumerable]]이며, for in은 이 값이 true로 셋팅되어 속성들만 반복할 수 있습니다. 이러한 속성들을 열거형 속성이라고 부르며, 객체의 모든 내장 메서드를 비롯해 각종 내장 프로퍼티 같은 비열거형 속성은 반복되지 않습니다. for of는 ES6에 추가된 새로운 컬렉션 전용 반복 구문입니다. for of를 사용하기 위해선 컬렉션 객체가 [Symbol.iterator] 속성을 가지고 있어야만 합니다.
- [√] 중첩 반복문에서 원하는 반복문을 제어(break/continue)하기 위한 방법은 무엇인가요?
    - break는 특정 조건을 달성해서 반복문을 탈출하고 싶을 때 사용하고, continue는 특정 조건을 달성해서 해당 코드를 건너뛰고 싶을 때 사용합니다.
- [√] 원본 배열을 건들지 않고 splice 한 배열을 얻기 위해서는 어떻게 해야하나요?
    - splice의 반환값을 다른 배열의 저장하고 splice(기존에 있던 인덱스, 0, 제거한값, 제거한값, …)을 해서 다시 기존의 배열에 저장합니다.
- [√] 원본 배열을 건들지 않고 splice 되어진 배열을 얻기 위해서는 어떻게 해야하나요?
    - **slice(start, end)** 메소드를 이용합니다.
- [√] 배열의 includes는 내부적으로 indexOf를 사용하여 결과가 -1인지 아닌 지를 반환할까요? 아니면 별도의 로직을 가지고 있을까요?
    - includes는 indexOf와 마찬가지로 완전 항등 연산자 ===을 사용한다는 점에서 같지만, includes는 NaN도 제대로 처리한다는 점에서 indexOf와 차이가 있습니다.
- [√] 아래 코드에서 출력되는 값  a일까요 h일까요? 만약 h라면 target[0]이 바뀌지 않기 위해서는 어떻게 해야할까요?

```jsx
 const target = ['a', 'b', 'c', 'd', 'e'];
 const target2 = target;
 target2[0] = 'h';
 console.log(target[0]);

/*
h입니다.
바뀌지 않게 하기 위해서는
*/
const target = ['a', 'b', 'c', 'd', 'e'];
let target1 = [];
for(let i = 0; i < target.length; i++){
	target1[i] = target[i];
}
const target2 = target1;
target2[0] = 'h';
console.log(target[0]);
```

- [√] 함수를 정의하는 3가지 방법에 대해서 설명하고 차이점을 작성해주세요
    - 함수 선언식, 함수 표현식, 화살표 함수가 있습니다. 함수 선언식은 호스팅에 영향을 받지만, 함수 표현식은 호이스팅에 영향을 받지 않습니다. 일반 함수는 this로 자신을 내포하고있는 상위 객체에 접근이 가능하지만, 화살표 함수는 this가 없습니다. 그래서 그냥 상위 외부 함수에서 this를 가져옵니다.
- [√] 함수의 파라미터의 수가 변할 수 있을 때, 어떤 식으로 파라미터를 받아야하나요?
    - 함수를 호출할 때 인수를 통해서 파라미터를 받을 수 있습니다.
- [√] a,b,c 라는 id를 가진 div가 중첩되어 있고 자신의 id값을 출력하는 함수가 각 div의 이벤트 리스너로 설정되어있다면, 원하는 이벤트가 발생했을 때 어떤 순서로 출력 되나요?
    - 순차적으로 a, b, c순으로 출력 될 것 같습니다.